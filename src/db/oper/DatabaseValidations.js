import AWS from "aws-sdk";
import uuid from "uuid";
import bcrypt from "bcrypt";
import _ from "lodash";
import Moment from "moment";

import { CONNECTION_LIST, TYPES, DEFAULT } from "../models/common/Attributes";
import WebError, { DATABASE_FAILURE, DATABASE_REJECTION, CLIENT_GENERIC } from "../../io/HttpErrors";
import env from "../../config/env";
import { accessKeyId, secretAccessKey } from "../../config/secrets.json";
import { ATTRIBUTES, ITEM, UPDATE } from "./CommonDBCrud";

const documentClient = new AWS.DynamoDB.DocumentClient({
  region: env.REGION,
  endpoint: env.DOMAIN,
  accessKeyId,
  secretAccessKey,
});

/**
 * Alters the Item object provided
 * @param {*} model
 * @param {*} item
 * @param {*} updateMethod
 */
export const prepProps = async (model, item, updateMethod) => {
  if (!_.isEmpty(item)) {
    item = generateKeys(model, item, updateMethod);
    item = await encryptKeys(model, item);
  }
  return item;
};

export const uniquenessCondition = (model, item) => {
  let conditionalExpression = ["isActive <> :isActive"];
  let ExpressionAttributeValues = { ":isActive": false };
  let ExpressionAttributeNames = {};
  for (let field in model.properties) {
    let fieldValue = model.properties[field];
    if (fieldValue.unique && !_.isNil(item[field])) {
      conditionalExpression.push(`#${field} <> :${field}`);
      ExpressionAttributeValues = {
        ...ExpressionAttributeValues,
        [`:${field}`]: item[field],
      };
      ExpressionAttributeNames = {
        ...ExpressionAttributeNames,
        [`#${field}`]: field,
      };
    }
  }
  return {
    ConditionExpression: conditionalExpression.join(" and "),
    ExpressionAttributeValues,
    ExpressionAttributeNames,
  };
};

/**
 * Validates the Item object provided against the Model Schema
 *
 * @param {Model} model - Local Model
 * @param {Object} item
 */
export const checkProps = async (model, item, requiredCheck = false) => {
  if (_.isNil(item)) {
    throw new WebError(DATABASE_REJECTION, "No query item provided for the Crud Action.");
  }
  await _.each(model.schema, async (fieldValue, field) => {
    if (_.isNil(item[field]) && fieldValue.required && requiredCheck) {
      throw new WebError(DATABASE_REJECTION, model.modelName + " Missing Required Field: " + field);
    } else if (_.isNil(item[field])) {
      return; //Null values don't have constructors
    } else if (_.isNil(fieldValue)) {
      // Provided more information than described in model
      console.warn("Model didn't have provided item field:", field);
      return;
    } else if (CONNECTION_LIST.includes(fieldValue.type.constructor.name)) {
      //Handle Connections
      let foriegnKey = item[field];
      await fieldValue.type.validator(foriegnKey).catch((e) => {
        throw e;
      });
    } else if (fieldValue.type === TYPES.DATE && new Moment(item[field]).isValid()) {
      //No Errors in here
    } else if (fieldValue.type.name !== item[field].constructor.name) {
      // Confirm types of provided items
      let errMsg =
        `Malformed query. Provided query type mismatches expected: '${fieldValue}' (${field}:${fieldValue.type.name})` +
        ` doesn't equal '${item[field]}' (${field}:${item[field].constructor.name}).`;
      throw new WebError(DATABASE_REJECTION, errMsg);
    }
  });
};

const encryptKeys = async (model, item) => {
  for (let field in item) {
    if (_.get(model, ["properties", field, "encrypted"], false)) {
      item[field] = await bcrypt.hash(item[field], 10);
    }
  }
  return item;
};

/**
 * Checks that the encrypted values from the database match that ones provided by the Query
 * Then skims out those keys
 *
 * @param {*} model
 * @param {*} requestedItem
 * @param {*} databaseItem
 */
const compareEncrypted = async (model, requestedItem, databaseItem) => {
  for (let field in requestedItem) {
    if (_.get(model, ["properties", field, "encrypted"], false)) {
      let match = await bcrypt.compare(requestedItem[field], databaseItem[field]);
      if (!match) {
        throw new WebError(CLIENT_GENERIC, "Credentials provided were incorrect");
      } else {
        databaseItem[field] = undefined;
      }
    }
  }

  return databaseItem;
};

const generateKeys = (model, item, state = DEFAULT) => {
  for (let field in model.properties) {
    let allowableGenerations = _.get(model, ["properties", field, "autoGenerated"], [DEFAULT]);
    if ((_.isArray(allowableGenerations) && allowableGenerations.includes(state)) || allowableGenerations === state) {
      if (model.properties[field].type === TYPES.DATE) {
        item[field] = new Moment().format();
      } else {
        item[field] = uuid.v4();
      }
    }
  }
  return item;
};

export const executor = async (model, method, params) => {
  try {
    params = { ...params, TableName: env.tableName(model.modelName) };
    console.log("executorREQ", params);
    let dbResponse = await documentClient[method](params).promise();
    console.log("executorRES", dbResponse);
    if (!_.isEmpty(dbResponse) && _.has(dbResponse, ATTRIBUTES)) {
      let validSkimmedResult = await compareEncrypted(_.get(params, ITEM), _.get(dbResponse, ATTRIBUTES));
      _.set(dbResponse, ATTRIBUTES, validSkimmedResult);
    }
    return dbResponse;
  } catch (error) {
    throw new WebError(DATABASE_FAILURE, error.message);
  }
};

/**
 * @todo
 * @param {*} Model
 * @param {*} filterExpression
 */
export const dynamoDBFilterMarshalling = (Model, filterExpression) => {
  let marshall = { ExpressionAttributeValues: {} };
  for (let key in filterExpression) {
    marshall.ExpressionAttributeNames[`#${key}`] = key;
    let type = Model.properties[key].type.dbName;
    marshall.ExpressionAttributeValues[`:${key}`] = {
      [type]: filterExpression[key],
    };
  }
};
